{
  "version": 3,
  "sources": ["../src/helpers.js", "../src/index.js"],
  "sourcesContent": ["export function getLightShadow(color) {\n  const shadows = [\n    `white 0px 0px 5px`,\n    `white 0px 0px 10px`,\n    `${color} 0px 0px 20px`,\n    `${color} 0px 0px 30px`,\n    `${color} 0px 0px 40px`,\n    `${color} 0px 0px 55px`,\n    `${color} 0px 0px 75px`,\n  ];\n  return shadows.join(\", \");\n}\n\nexport function getDarkShadow(dimStep = 10) {\n  const color = RGB.from_hex(\"#aaa\");\n  const shadows = [\n    `${color.dim(dimStep).toHex()} 0px 1px 0px`,\n    `${color.dim(dimStep * 2).toHex()} 0px 2px 0px`,\n    `${color.dim(dimStep * 3).toHex()} 0px 3px 0px`,\n    `${color.dim(dimStep * 4).toHex()} 0px 4px 0px`,\n    `rgba(0, 0, 0, 0.23) 0px 0px 5px`,\n    `rgba(0, 0, 0, 0.43) 0px 1px 3px`,\n    `rgba(0, 0, 0, 0.4) 1px 4px 6px`,\n    `rgba(0, 0, 0, 0.38) 0px 5px 10px`,\n    `rgba(0, 0, 0, 0.25) 3px 7px 12px`,\n  ];\n  return shadows.join(\", \");\n}\n\nexport class RGB {\n  constructor(rgb = [0, 0, 0]) {\n    this.r = rgb[0];\n    this.g = rgb[1];\n    this.b = rgb[2];\n  }\n  static from_hex(hex) {\n    if (hex.match(/[\\w\\d]/g).length == 3) {\n      var aRgbHex = hex.match(/[\\w\\d]/g);\n      var aRgb = [\n        parseInt(aRgbHex[0], 16) * 17,\n        parseInt(aRgbHex[1], 16) * 17,\n        parseInt(aRgbHex[2], 16) * 17\n      ];\n    } else {\n      var aRgbHex = hex.match(/[\\w\\d]{2}/g);\n      var aRgb = [\n        parseInt(aRgbHex[0], 16),\n        parseInt(aRgbHex[1], 16),\n        parseInt(aRgbHex[2], 16)\n      ];\n    }\n    return new RGB(aRgb);\n  }\n\n  toHex() {\n    const convertColor = (c) => c.toString(16).padStart(2, '0')\n    return `#${convertColor(this.r)}${convertColor(this.g)}${convertColor(this.b)}`\n  }\n\n  dim(v) {\n    const calc = c => Math.max(0, c - v)\n    this.r = calc(this.r);\n    this.g = calc(this.g);\n    this.b = calc(this.b);\n    return this;\n  }\n  bright(v) {\n    const calc = c => Math.min(255, c + v)\n    this.r = calc(this.r);\n    this.g = calc(this.g);\n    this.b = calc(this.b);\n    return this;\n  }\n\n  toCssRGB() {\n    return `rgb(${this.r}, ${this.g}, ${this.b})`\n  }\n}\n\nexport function getSpelling(text) {\n  return text.match(/[\u0430-\u044F]/i) ? \"cyr\" : \"lat\";\n}\n\nexport function onDrag(e, $el, $container, dragStart = { x: 0, y: 0 }) {\n  e.preventDefault();\n  // calculate the new cursor position:\n  const innerBorderOffset = 10;\n  const pos1 = dragStart.x - e.clientX;\n  const pos2 = dragStart.y - e.clientY;\n\n  const top = Math.min(\n    $container.clientHeight - $el.clientHeight - innerBorderOffset,\n    Math.max(0 + innerBorderOffset, $el.offsetTop - pos2)\n  );\n  const left = Math.min(\n    $container.clientWidth - $el.clientWidth - innerBorderOffset,\n    Math.max(0 + innerBorderOffset, $el.offsetLeft - pos1)\n  );\n\n  return {\n    dragStart: { y: e.clientY, x: e.clientX },\n    state: { y: top + \"px\", x: left + \"px\" }\n  }\n}", "import { getDarkShadow, getLightShadow, getSpelling, onDrag } from \"./helpers\";\n\ndocument.addEventListener(\"alpine:init\", () => {\n  Alpine.data(\"wnca\", () => {\n    const UNDERLAY_COLOR = 'rgba(0, 0, 0, 0.15)';\n    return {\n      init() {\n        this.colors = JSON.parse(this.$refs.colors_json.innerHTML);\n        this.$watch(\"val.text\", () => this.onTextChange());\n        this.$watch(\"val.font\", () => this.onFontChange());\n        this.$watch(\"state.underlay\", () => this.onUnderlayChange());\n        this.$watch(\"state.spelling\", (o, n) => this.onSpellingChange(o, n));\n\n        this._fonts = JSON.parse(this.$refs.fonts_json.innerHTML);\n        this.updateFonts();\n      },\n      UNDERLAY_COLOR,\n      _fonts: [],\n      fonts: [],\n      colors: [],\n\n      getColorByHex(hex) {\n        return this.colors.find((i) => i.color == hex);\n      },\n      tabs: [\"Text\", \"Font\", \"Color\"],\n      activeTab: \"Text\",\n      cache: {\n        loadedFonts: [],\n      },\n      state: {\n        dragged: false,\n        underlay: \"no\",\n        spelling: \"lat\",\n        font: null,\n        color: {\n          preview: \"\",\n          detailPreview: \"\",\n        },\n        text: {\n          light: true,\n          align: \"center\",\n          fontSize: \"\",\n          dragStart: {\n            x: 0,\n            y: 0,\n          },\n          x: \"auto\",\n          y: \"17%\",\n        },\n      },\n\n      // FormValues\n      val: {\n        text: \"\",\n        font: \"\",\n        color: \"\",\n      },\n\n      onUnderlayChange() {\n\n      },\n      onTextChange() {\n        this.updateFontSize();\n        this.updateSpelling();\n      },\n      onFontChange() {\n        this.updateFontSize();\n      },\n      onSpellingChange(ov, nv) {\n        if (nv !== ov) this.updateFonts();\n      },\n      onColorChange(color) {\n        this.setColor(color);\n      },\n      onTabChange(tab) {\n        this.setTab(tab);\n      },\n\n      setTab(tab) {\n        this.activeTab = tab;\n      },\n      setUnderlay(underlay) {\n        this.state.underlay = underlay;\n      },\n\n\n      async setFont(font) {\n        if (!this.cache.loadedFonts.includes(font.name)) {\n          document.fonts.add(\n            await new FontFace(font.name, `url(${font.link})`, {\n              style: \"normal\",\n              weight: 700,\n            }).load()\n          );\n        }\n        this.val.font = font.name;\n        this.state.font = font;\n        this.updateFontSize();\n      },\n      async setColor(color) {\n        this.state.color = color;\n        this.val.color = color.color;\n      },\n      getLightShadow() {\n        return getLightShadow(this.val.color);\n      },\n      getDarkShadow() {\n        return getDarkShadow()\n      },\n      toggleLight(status) {\n        this.state.text.light = status;\n      },\n\n      onTextDrag(e) {\n        this.state.dragged = true;\n        const { dragStart, state } = onDrag(e, this.$refs.text, this.$refs.preview, this.state.text.dragStart);\n        this.state.text.dragStart = dragStart;\n        this.state.text.x = state.x;\n        this.state.text.y = state.y;\n      },\n\n      get fontBaseSize() {\n        return this.state.font.base_size;\n      },\n\n      updateFonts() {\n        const fontIsNull = this.state.font == null;\n        const fontHasCurrentSpelling =\n          !fontIsNull && this.state.font.spelling.includes(this.state.spelling);\n\n        this.fonts = this._fonts.filter((font) =>\n          font.spelling.includes(this.state.spelling)\n        );\n        if (fontIsNull || !fontHasCurrentSpelling) this.setFont(this.fonts[0]);\n      },\n\n      updateSpelling() {\n        this.state.spelling = getSpelling(this.val.text);\n      },\n      updateFontSize() {\n        const previewWidth = this.$refs.preview.clientWidth;\n        const textWidth = this.$refs.text.clientWidth;\n\n        this.state.text.fontSize = Math.min(\n          this.fontBaseSize,\n          this.state.text.fontSize / (textWidth / previewWidth)\n        );\n\n        if (this.val.text.length == 0)\n          this.state.text.fontSize = this.fontBaseSize;\n\n        // If text is out of preview - move it to right by delta of collision\n        if (parseInt(this.state.text.x) + textWidth > previewWidth) {\n          this.state.text.x = previewWidth - textWidth + 'px';\n        }\n      },\n\n      get textValue() {\n        return this.val.text.replaceAll('\\\\n', '<br>') || 'Your Text'\n      },\n      textValueBind: {\n        [\"x-html\"]: \"textValue\",\n        \":class\": \"'text-value'\",\n        \":style\": `{\n          textShadow: state.text.light ? getLightShadow() : getDarkShadow(),\n          color: state.text.light ? 'white' : val.color,\n      }`\n      },\n      textUnderlayBind: {\n        [\"x-html\"]: \"textValue\",\n        \":class\": \"'text-underlay-byform'\",\n        \":style\": \"`-webkit-text-stroke: ${state.font.underlay_by_form_size}px ${UNDERLAY_COLOR}; `\"\n      },\n      textWrapperBind: {\n        \"class\": \"text__wrapper\",\n        \":style\": `{\"background-color\": state.underlay == 'rectangle' ? '${UNDERLAY_COLOR}' :\"transparent\" }`,\n      },\n      textBind: {\n        [\"x-ref\"]: \"text\",\n        \":class\": \"'text' + ' underlay__' + state.underlay + (state.dragged ? '' : ' dragged')\",\n\n        \":style\": `{\n          top: state.text.y,\n          left: state.text.x,\n          fontFamily: val.font,\n          fontSize: state.text.fontSize + 'px',\n          textAlign: state.text.align,\n        }`,\n        [\"@mousedown\"](e) {\n          e = e || window.event;\n          e.preventDefault();\n          // get the mouse cursor position at startup:\n          this.state.text.dragStart.x = e.clientX;\n          this.state.text.dragStart.y = e.clientY;\n          document.onmouseup = () => {\n            document.onmouseup = null;\n            document.onmousemove = null;\n          };\n          // call a function whenever the cursor moves:\n          document.onmousemove = this.onTextDrag.bind(this);\n        },\n      },\n    }\n  });\n});\n"],
  "mappings": "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",
  "names": ["getLightShadow", "color", "getDarkShadow", "dimStep", "RGB", "rgb", "hex", "aRgbHex", "aRgb", "convertColor", "c", "v", "calc", "getSpelling", "text", "onDrag", "e", "$el", "$container", "dragStart", "innerBorderOffset", "pos1", "pos2", "top", "left", "UNDERLAY_COLOR", "o", "n", "hex", "i", "ov", "nv", "color", "tab", "underlay", "font", "getLightShadow", "getDarkShadow", "status", "e", "dragStart", "state", "onDrag", "fontIsNull", "fontHasCurrentSpelling", "getSpelling", "previewWidth", "textWidth"]
}
